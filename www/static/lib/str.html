<!doctype html>
<head>
    <meta charset="utf-8">
    <title>str.oak | Oak programming language</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/lib.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;700&family=IBM+Plex+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
</head>
<body>
    <header>
        <div class="overlay">
            <div class="home">
                <a href="/">Oak</a>
            </div>
            <nav>
                <a href="/lib/"><span class="desktop">standard library</span><span class="mobile">stdlib</span></a>
                <a href="#start">download</a>
                <a href="https://github.com/thesephist/oak" target="_blank">source ↗</a>
            </nav>
        </div>
    </header>
    <main aria-role="main">
        <article class="overlay stdlib">
            <h1>str.oak</h1>
            <p class="stdlibLink">
                <a href="/lib/">&larr; Standard library</a>
                <a href="https://github.com/thesephist/oak/blob/main/lib/str.oak">See on GitHub ↗</a>
            </p>
            <pre><code><span class="oak-comment">// libstr is the core string library for Oak.</span>
<span class="oak-comment">//</span>
<span class="oak-comment">// It provides a set of utility functions for working with strings and data</span>
<span class="oak-comment">// encoded in strings in Oak programs.</span>

<span class="oak-leftBrace">{</span><span class="oak-newline">
	</span><span class="oak-identifier">default</span><span class="oak-colon">: </span><span class="oak-identifier">default</span><span class="oak-newline">
	</span><span class="oak-identifier">slice</span><span class="oak-colon">: </span><span class="oak-identifier">slice</span><span class="oak-newline">
	</span><span class="oak-identifier">reduce</span><span class="oak-colon">: </span><span class="oak-identifier">reduce</span>
<span class="oak-rightBrace">} </span><span class="oak-assign">:= </span><span class="oak-fnName">import</span><span class="oak-leftParen">(</span><span class="oak-stringLiteral">'std'</span><span class="oak-rightParen">)</span>

<span class="oak-comment">// checkRange is a higher-order function that returns a function `checker`,</span>
<span class="oak-comment">// which reports whether a given char is within the range [lo, hi], inclusive.</span>
<span class="oak-fnKeyword">fn </span><span class="oak-fnName">checkRange</span><span class="oak-leftParen">(</span><span class="oak-identifier">lo</span><span class="oak-comma">, </span><span class="oak-identifier">hi</span><span class="oak-rightParen">) </span><span class="oak-fnKeyword">fn </span><span class="oak-fnName">checker</span><span class="oak-leftParen">(</span><span class="oak-identifier">c</span><span class="oak-rightParen">) </span><span class="oak-leftBrace">{</span><span class="oak-newline">
	</span><span class="oak-identifier">p </span><span class="oak-assign">:= </span><span class="oak-fnName">codepoint</span><span class="oak-leftParen">(</span><span class="oak-identifier">c</span><span class="oak-rightParen">)</span><span class="oak-newline">
	</span><span class="oak-identifier">lo </span><span class="oak-leq">&lt;= </span><span class="oak-identifier">p </span><span class="oak-and">&amp; </span><span class="oak-identifier">p </span><span class="oak-leq">&lt;= </span><span class="oak-identifier">hi</span>
<span class="oak-rightBrace">}</span>

<span class="oak-comment">// upper? reports whether a given char is an uppercase ASCII letter</span>
<span class="oak-fnKeyword">fn </span><span class="oak-fnName">upper?</span><span class="oak-leftParen">(</span><span class="oak-identifier">c</span><span class="oak-rightParen">) </span><span class="oak-identifier">c </span><span class="oak-geq">>= </span><span class="oak-stringLiteral">'A' </span><span class="oak-and">&amp; </span><span class="oak-identifier">c </span><span class="oak-leq">&lt;= </span><span class="oak-stringLiteral">'Z'</span>
<span class="oak-comment">// lower? reports whether a given char is a lowercase ASCII letter</span>
<span class="oak-fnKeyword">fn </span><span class="oak-fnName">lower?</span><span class="oak-leftParen">(</span><span class="oak-identifier">c</span><span class="oak-rightParen">) </span><span class="oak-identifier">c </span><span class="oak-geq">>= </span><span class="oak-stringLiteral">'a' </span><span class="oak-and">&amp; </span><span class="oak-identifier">c </span><span class="oak-leq">&lt;= </span><span class="oak-stringLiteral">'z'</span>
<span class="oak-comment">// digit? reports whether a given char is an ASCII digit</span>
<span class="oak-fnKeyword">fn </span><span class="oak-fnName">digit?</span><span class="oak-leftParen">(</span><span class="oak-identifier">c</span><span class="oak-rightParen">) </span><span class="oak-identifier">c </span><span class="oak-geq">>= </span><span class="oak-stringLiteral">'0' </span><span class="oak-and">&amp; </span><span class="oak-identifier">c </span><span class="oak-leq">&lt;= </span><span class="oak-stringLiteral">'9'</span>
<span class="oak-comment">// space? reports whether a given char is an ASCII whitespace</span>
<span class="oak-fnKeyword">fn </span><span class="oak-fnName">space?</span><span class="oak-leftParen">(</span><span class="oak-identifier">c</span><span class="oak-rightParen">) </span><span class="oak-ifKeyword">if </span><span class="oak-identifier">c </span><span class="oak-leftBrace">{</span><span class="oak-newline">
	</span><span class="oak-stringLiteral">' '</span><span class="oak-comma">, </span><span class="oak-stringLiteral">'\t'</span><span class="oak-comma">, </span><span class="oak-stringLiteral">'\n'</span><span class="oak-comma">, </span><span class="oak-stringLiteral">'\r'</span><span class="oak-comma">, </span><span class="oak-stringLiteral">'\f' </span><span class="oak-branchArrow">-> </span><span class="oak-trueLiteral">true</span><span class="oak-newline">
	</span><span class="oak-underscore">_ </span><span class="oak-branchArrow">-> </span><span class="oak-falseLiteral">false</span>
<span class="oak-rightBrace">}</span>
<span class="oak-comment">// letter? reports whether a given char is an ASCII letter</span>
<span class="oak-fnKeyword">fn </span><span class="oak-fnName">letter?</span><span class="oak-leftParen">(</span><span class="oak-identifier">c</span><span class="oak-rightParen">) </span><span class="oak-fnName">upper?</span><span class="oak-leftParen">(</span><span class="oak-identifier">c</span><span class="oak-rightParen">) </span><span class="oak-or">| </span><span class="oak-fnName">lower?</span><span class="oak-leftParen">(</span><span class="oak-identifier">c</span><span class="oak-rightParen">)</span>
<span class="oak-comment">// word? reports whether a given char is a letter or a digit</span>
<span class="oak-fnKeyword">fn </span><span class="oak-fnName">word?</span><span class="oak-leftParen">(</span><span class="oak-identifier">c</span><span class="oak-rightParen">) </span><span class="oak-fnName">letter?</span><span class="oak-leftParen">(</span><span class="oak-identifier">c</span><span class="oak-rightParen">) </span><span class="oak-or">| </span><span class="oak-fnName">digit?</span><span class="oak-leftParen">(</span><span class="oak-identifier">c</span><span class="oak-rightParen">)</span>

<span class="oak-comment">// join concatenates together a list of strings into a single string, where</span>
<span class="oak-comment">// each original string in the list is separated by `joiner`. Joiner is the</span>
<span class="oak-comment">// empty string by default.</span>
<span class="oak-fnKeyword">fn </span><span class="oak-fnName">join</span><span class="oak-leftParen">(</span><span class="oak-identifier">strings</span><span class="oak-comma">, </span><span class="oak-identifier">joiner</span><span class="oak-rightParen">) </span><span class="oak-leftBrace">{</span><span class="oak-newline">
	</span><span class="oak-identifier">joiner </span><span class="oak-assign">:= </span><span class="oak-fnName">default</span><span class="oak-leftParen">(</span><span class="oak-identifier">joiner</span><span class="oak-comma">, </span><span class="oak-stringLiteral">''</span><span class="oak-rightParen">)</span><span class="oak-newline">
	</span><span class="oak-ifKeyword">if </span><span class="oak-fnName">len</span><span class="oak-leftParen">(</span><span class="oak-identifier">strings</span><span class="oak-rightParen">) </span><span class="oak-leftBrace">{</span><span class="oak-newline">
		</span><span class="oak-numberLiteral">0 </span><span class="oak-branchArrow">-> </span><span class="oak-stringLiteral">''</span><span class="oak-newline">
		</span><span class="oak-underscore">_ </span><span class="oak-branchArrow">-> </span><span class="oak-identifier">strings </span><span class="oak-pipeArrow">|> </span><span class="oak-fnName">slice</span><span class="oak-leftParen">(</span><span class="oak-numberLiteral">1</span><span class="oak-rightParen">) </span><span class="oak-pipeArrow">|> </span><span class="oak-fnName">reduce</span><span class="oak-leftParen">(</span><span class="oak-identifier">strings</span><span class="oak-dot">.</span><span class="oak-numberLiteral">0</span><span class="oak-comma">, </span><span class="oak-fnKeyword">fn</span><span class="oak-leftParen">(</span><span class="oak-identifier">a</span><span class="oak-comma">, </span><span class="oak-identifier">b</span><span class="oak-rightParen">) </span><span class="oak-identifier">a </span><span class="oak-plus">+ </span><span class="oak-identifier">joiner </span><span class="oak-plus">+ </span><span class="oak-identifier">b</span><span class="oak-rightParen">)</span><span class="oak-newline">
	</span><span class="oak-rightBrace">}</span>
<span class="oak-rightBrace">}</span>

<span class="oak-comment">// startsWith? reports whether a string starts with the substring `prefix`.</span>
<span class="oak-fnKeyword">fn </span><span class="oak-fnName">startsWith?</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-comma">, </span><span class="oak-identifier">prefix</span><span class="oak-rightParen">) </span><span class="oak-identifier">s </span><span class="oak-pipeArrow">|> </span><span class="oak-fnName">slice</span><span class="oak-leftParen">(</span><span class="oak-numberLiteral">0</span><span class="oak-comma">, </span><span class="oak-fnName">len</span><span class="oak-leftParen">(</span><span class="oak-identifier">prefix</span><span class="oak-rightParen">)</span><span class="oak-rightParen">) </span><span class="oak-eq">= </span><span class="oak-identifier">prefix</span>

<span class="oak-comment">// endsWith? reports whether a string ends with the substring `suffix`.</span>
<span class="oak-fnKeyword">fn </span><span class="oak-fnName">endsWith?</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-comma">, </span><span class="oak-identifier">suffix</span><span class="oak-rightParen">) </span><span class="oak-identifier">s </span><span class="oak-pipeArrow">|> </span><span class="oak-fnName">slice</span><span class="oak-leftParen">(</span><span class="oak-fnName">len</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-rightParen">) </span><span class="oak-minus">- </span><span class="oak-fnName">len</span><span class="oak-leftParen">(</span><span class="oak-identifier">suffix</span><span class="oak-rightParen">)</span><span class="oak-rightParen">) </span><span class="oak-eq">= </span><span class="oak-identifier">suffix</span>

<span class="oak-comment">// _matchesAt? is an internal helper that reports whether a given string `s`</span>
<span class="oak-comment">// contains the substring `substr` at index `idx`. It performs this comparison</span>
<span class="oak-comment">// efficiently, without unnecessary copying compared to other approaches.</span>
<span class="oak-fnKeyword">fn </span><span class="oak-fnName">_matchesAt?</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-comma">, </span><span class="oak-identifier">substr</span><span class="oak-comma">, </span><span class="oak-identifier">idx</span><span class="oak-rightParen">) </span><span class="oak-ifKeyword">if </span><span class="oak-fnName">len</span><span class="oak-leftParen">(</span><span class="oak-identifier">substr</span><span class="oak-rightParen">) </span><span class="oak-leftBrace">{</span><span class="oak-newline">
	</span><span class="oak-numberLiteral">0 </span><span class="oak-branchArrow">-> </span><span class="oak-trueLiteral">true</span><span class="oak-newline">
	</span><span class="oak-numberLiteral">1 </span><span class="oak-branchArrow">-> </span><span class="oak-identifier">s</span><span class="oak-dot">.</span><span class="oak-leftParen">(</span><span class="oak-identifier">idx</span><span class="oak-rightParen">) </span><span class="oak-eq">= </span><span class="oak-identifier">substr</span><span class="oak-newline">
	</span><span class="oak-underscore">_ </span><span class="oak-branchArrow">-> </span><span class="oak-leftBrace">{</span><span class="oak-newline">
		</span><span class="oak-identifier">max </span><span class="oak-assign">:= </span><span class="oak-fnName">len</span><span class="oak-leftParen">(</span><span class="oak-identifier">substr</span><span class="oak-rightParen">)</span><span class="oak-newline">
		</span><span class="oak-fnKeyword">fn </span><span class="oak-fnName">sub</span><span class="oak-leftParen">(</span><span class="oak-identifier">i</span><span class="oak-rightParen">) </span><span class="oak-ifKeyword">if </span><span class="oak-identifier">i </span><span class="oak-leftBrace">{</span><span class="oak-newline">
			</span><span class="oak-identifier">max </span><span class="oak-branchArrow">-> </span><span class="oak-trueLiteral">true</span><span class="oak-newline">
			</span><span class="oak-underscore">_ </span><span class="oak-branchArrow">-> </span><span class="oak-ifKeyword">if </span><span class="oak-identifier">s</span><span class="oak-dot">.</span><span class="oak-leftParen">(</span><span class="oak-identifier">idx </span><span class="oak-plus">+ </span><span class="oak-identifier">i</span><span class="oak-rightParen">) </span><span class="oak-leftBrace">{</span><span class="oak-newline">
				</span><span class="oak-identifier">substr</span><span class="oak-dot">.</span><span class="oak-leftParen">(</span><span class="oak-identifier">i</span><span class="oak-rightParen">) </span><span class="oak-branchArrow">-> </span><span class="oak-fnName">sub</span><span class="oak-leftParen">(</span><span class="oak-identifier">i </span><span class="oak-plus">+ </span><span class="oak-numberLiteral">1</span><span class="oak-rightParen">)</span><span class="oak-newline">
				</span><span class="oak-underscore">_ </span><span class="oak-branchArrow">-> </span><span class="oak-falseLiteral">false</span><span class="oak-newline">
			</span><span class="oak-rightBrace">}</span><span class="oak-newline">
		</span><span class="oak-rightBrace">}</span><span class="oak-newline">
		</span><span class="oak-fnName">sub</span><span class="oak-leftParen">(</span><span class="oak-numberLiteral">0</span><span class="oak-rightParen">)</span><span class="oak-newline">
	</span><span class="oak-rightBrace">}</span>
<span class="oak-rightBrace">}</span>

<span class="oak-comment">// indexOf returns the first index at which the given substring `substr`</span>
<span class="oak-comment">// appears in the string `s`. If the substring does not exist, it returns -1.</span>
<span class="oak-fnKeyword">fn </span><span class="oak-fnName">indexOf</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-comma">, </span><span class="oak-identifier">substr</span><span class="oak-rightParen">) </span><span class="oak-leftBrace">{</span><span class="oak-newline">
	</span><span class="oak-identifier">max </span><span class="oak-assign">:= </span><span class="oak-fnName">len</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-rightParen">) </span><span class="oak-minus">- </span><span class="oak-fnName">len</span><span class="oak-leftParen">(</span><span class="oak-identifier">substr</span><span class="oak-rightParen">)</span><span class="oak-newline">
	</span><span class="oak-fnKeyword">fn </span><span class="oak-fnName">sub</span><span class="oak-leftParen">(</span><span class="oak-identifier">i</span><span class="oak-rightParen">) </span><span class="oak-ifKeyword">if </span><span class="oak-fnName">_matchesAt?</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-comma">, </span><span class="oak-identifier">substr</span><span class="oak-comma">, </span><span class="oak-identifier">i</span><span class="oak-rightParen">) </span><span class="oak-leftBrace">{</span><span class="oak-newline">
		</span><span class="oak-trueLiteral">true </span><span class="oak-branchArrow">-> </span><span class="oak-identifier">i</span><span class="oak-newline">
		</span><span class="oak-underscore">_ </span><span class="oak-branchArrow">-> </span><span class="oak-ifKeyword">if </span><span class="oak-identifier">i </span><span class="oak-less">&lt; </span><span class="oak-identifier">max </span><span class="oak-leftBrace">{</span><span class="oak-newline">
			</span><span class="oak-trueLiteral">true </span><span class="oak-branchArrow">-> </span><span class="oak-fnName">sub</span><span class="oak-leftParen">(</span><span class="oak-identifier">i </span><span class="oak-plus">+ </span><span class="oak-numberLiteral">1</span><span class="oak-rightParen">)</span><span class="oak-newline">
			</span><span class="oak-underscore">_ </span><span class="oak-branchArrow">-> </span><span class="oak-minus">-</span><span class="oak-numberLiteral">1</span><span class="oak-newline">
		</span><span class="oak-rightBrace">}</span><span class="oak-newline">
	</span><span class="oak-rightBrace">}</span><span class="oak-newline">
	</span><span class="oak-fnName">sub</span><span class="oak-leftParen">(</span><span class="oak-numberLiteral">0</span><span class="oak-rightParen">)</span>
<span class="oak-rightBrace">}</span>

<span class="oak-comment">// contains? reports whether the string `s` contains the substring `substr`.</span>
<span class="oak-fnKeyword">fn </span><span class="oak-fnName">contains?</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-comma">, </span><span class="oak-identifier">substr</span><span class="oak-rightParen">) </span><span class="oak-fnName">indexOf</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-comma">, </span><span class="oak-identifier">substr</span><span class="oak-rightParen">) </span><span class="oak-geq">>= </span><span class="oak-numberLiteral">0</span>

<span class="oak-comment">// cut splits the given string at most once by the given separator substring.</span>
<span class="oak-comment">// If the separator is found in s, it returns the substring before and after</span>
<span class="oak-comment">// the separator as the list [before, after]. If the separator is not found, it</span>
<span class="oak-comment">// returns [s, ''].</span>
<span class="oak-fnKeyword">fn </span><span class="oak-fnName">cut</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-comma">, </span><span class="oak-identifier">sep</span><span class="oak-rightParen">) </span><span class="oak-ifKeyword">if </span><span class="oak-identifier">idx </span><span class="oak-assign">:= </span><span class="oak-fnName">indexOf</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-comma">, </span><span class="oak-identifier">sep</span><span class="oak-rightParen">) </span><span class="oak-leftBrace">{</span><span class="oak-newline">
	</span><span class="oak-minus">-</span><span class="oak-numberLiteral">1 </span><span class="oak-branchArrow">-> </span><span class="oak-leftBracket">[</span><span class="oak-identifier">s</span><span class="oak-comma">, </span><span class="oak-stringLiteral">''</span><span class="oak-rightBracket">]</span><span class="oak-newline">
	</span><span class="oak-underscore">_ </span><span class="oak-branchArrow">-> </span><span class="oak-leftBracket">[</span><span class="oak-newline">
		</span><span class="oak-identifier">s </span><span class="oak-pipeArrow">|> </span><span class="oak-fnName">slice</span><span class="oak-leftParen">(</span><span class="oak-numberLiteral">0</span><span class="oak-comma">, </span><span class="oak-identifier">idx</span><span class="oak-rightParen">)</span><span class="oak-newline">
		</span><span class="oak-identifier">s </span><span class="oak-pipeArrow">|> </span><span class="oak-fnName">slice</span><span class="oak-leftParen">(</span><span class="oak-identifier">idx </span><span class="oak-plus">+ </span><span class="oak-fnName">len</span><span class="oak-leftParen">(</span><span class="oak-identifier">sep</span><span class="oak-rightParen">)</span><span class="oak-rightParen">)</span><span class="oak-newline">
	</span><span class="oak-rightBracket">]</span>
<span class="oak-rightBrace">}</span>

<span class="oak-comment">// lower returns a string where any uppercase letter in `s` has been down-cased.</span>
<span class="oak-fnKeyword">fn </span><span class="oak-fnName">lower</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-rightParen">) </span><span class="oak-identifier">s </span><span class="oak-pipeArrow">|> </span><span class="oak-fnName">reduce</span><span class="oak-leftParen">(</span><span class="oak-stringLiteral">''</span><span class="oak-comma">, </span><span class="oak-fnKeyword">fn</span><span class="oak-leftParen">(</span><span class="oak-identifier">acc</span><span class="oak-comma">, </span><span class="oak-identifier">c</span><span class="oak-rightParen">) </span><span class="oak-ifKeyword">if </span><span class="oak-fnName">upper?</span><span class="oak-leftParen">(</span><span class="oak-identifier">c</span><span class="oak-rightParen">) </span><span class="oak-leftBrace">{</span><span class="oak-newline">
	</span><span class="oak-trueLiteral">true </span><span class="oak-branchArrow">-> </span><span class="oak-identifier">acc </span><span class="oak-pushArrow">&lt;&lt; </span><span class="oak-fnName">char</span><span class="oak-leftParen">(</span><span class="oak-fnName">codepoint</span><span class="oak-leftParen">(</span><span class="oak-identifier">c</span><span class="oak-rightParen">) </span><span class="oak-plus">+ </span><span class="oak-numberLiteral">32</span><span class="oak-rightParen">)</span><span class="oak-newline">
	</span><span class="oak-underscore">_ </span><span class="oak-branchArrow">-> </span><span class="oak-identifier">acc </span><span class="oak-pushArrow">&lt;&lt; </span><span class="oak-identifier">c</span>
<span class="oak-rightBrace">}</span><span class="oak-rightParen">)</span>

<span class="oak-comment">// upper returns a string where any lowercase letter in `s` has been up-cased.</span>
<span class="oak-fnKeyword">fn </span><span class="oak-fnName">upper</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-rightParen">) </span><span class="oak-identifier">s </span><span class="oak-pipeArrow">|> </span><span class="oak-fnName">reduce</span><span class="oak-leftParen">(</span><span class="oak-stringLiteral">''</span><span class="oak-comma">, </span><span class="oak-fnKeyword">fn</span><span class="oak-leftParen">(</span><span class="oak-identifier">acc</span><span class="oak-comma">, </span><span class="oak-identifier">c</span><span class="oak-rightParen">) </span><span class="oak-ifKeyword">if </span><span class="oak-fnName">lower?</span><span class="oak-leftParen">(</span><span class="oak-identifier">c</span><span class="oak-rightParen">) </span><span class="oak-leftBrace">{</span><span class="oak-newline">
	</span><span class="oak-trueLiteral">true </span><span class="oak-branchArrow">-> </span><span class="oak-identifier">acc </span><span class="oak-pushArrow">&lt;&lt; </span><span class="oak-fnName">char</span><span class="oak-leftParen">(</span><span class="oak-fnName">codepoint</span><span class="oak-leftParen">(</span><span class="oak-identifier">c</span><span class="oak-rightParen">) </span><span class="oak-minus">- </span><span class="oak-numberLiteral">32</span><span class="oak-rightParen">)</span><span class="oak-newline">
	</span><span class="oak-underscore">_ </span><span class="oak-branchArrow">-> </span><span class="oak-identifier">acc </span><span class="oak-pushArrow">&lt;&lt; </span><span class="oak-identifier">c</span>
<span class="oak-rightBrace">}</span><span class="oak-rightParen">)</span>

<span class="oak-fnKeyword">fn </span><span class="oak-fnName">_replaceNonEmpty</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-comma">, </span><span class="oak-identifier">old</span><span class="oak-comma">, </span><span class="oak-identifier">new</span><span class="oak-rightParen">) </span><span class="oak-leftBrace">{</span><span class="oak-newline">
	</span><span class="oak-identifier">lold </span><span class="oak-assign">:= </span><span class="oak-fnName">len</span><span class="oak-leftParen">(</span><span class="oak-identifier">old</span><span class="oak-rightParen">)</span><span class="oak-newline">
	</span><span class="oak-identifier">lnew </span><span class="oak-assign">:= </span><span class="oak-fnName">len</span><span class="oak-leftParen">(</span><span class="oak-identifier">new</span><span class="oak-rightParen">)</span><span class="oak-newline">
	</span><span class="oak-fnKeyword">fn </span><span class="oak-fnName">sub</span><span class="oak-leftParen">(</span><span class="oak-identifier">acc</span><span class="oak-comma">, </span><span class="oak-identifier">i</span><span class="oak-rightParen">) </span><span class="oak-ifKeyword">if </span><span class="oak-fnName">_matchesAt?</span><span class="oak-leftParen">(</span><span class="oak-identifier">acc</span><span class="oak-comma">, </span><span class="oak-identifier">old</span><span class="oak-comma">, </span><span class="oak-identifier">i</span><span class="oak-rightParen">) </span><span class="oak-leftBrace">{</span><span class="oak-newline">
		</span><span class="oak-trueLiteral">true </span><span class="oak-branchArrow">-> </span><span class="oak-fnName">sub</span><span class="oak-leftParen">(</span><span class="oak-newline">
			</span><span class="oak-fnName">slice</span><span class="oak-leftParen">(</span><span class="oak-identifier">acc</span><span class="oak-comma">, </span><span class="oak-numberLiteral">0</span><span class="oak-comma">, </span><span class="oak-identifier">i</span><span class="oak-rightParen">) </span><span class="oak-plus">+ </span><span class="oak-identifier">new </span><span class="oak-plus">+ </span><span class="oak-fnName">slice</span><span class="oak-leftParen">(</span><span class="oak-identifier">acc</span><span class="oak-comma">, </span><span class="oak-identifier">i </span><span class="oak-plus">+ </span><span class="oak-identifier">lold</span><span class="oak-rightParen">)</span><span class="oak-newline">
			</span><span class="oak-identifier">i </span><span class="oak-plus">+ </span><span class="oak-identifier">lnew</span><span class="oak-newline">
		</span><span class="oak-rightParen">)</span><span class="oak-newline">
		</span><span class="oak-underscore">_ </span><span class="oak-branchArrow">-> </span><span class="oak-ifKeyword">if </span><span class="oak-identifier">i </span><span class="oak-less">&lt; </span><span class="oak-fnName">len</span><span class="oak-leftParen">(</span><span class="oak-identifier">acc</span><span class="oak-rightParen">) </span><span class="oak-leftBrace">{</span><span class="oak-newline">
			</span><span class="oak-trueLiteral">true </span><span class="oak-branchArrow">-> </span><span class="oak-fnName">sub</span><span class="oak-leftParen">(</span><span class="oak-identifier">acc</span><span class="oak-comma">, </span><span class="oak-identifier">i </span><span class="oak-plus">+ </span><span class="oak-numberLiteral">1</span><span class="oak-rightParen">)</span><span class="oak-newline">
			</span><span class="oak-underscore">_ </span><span class="oak-branchArrow">-> </span><span class="oak-identifier">acc</span><span class="oak-newline">
		</span><span class="oak-rightBrace">}</span><span class="oak-newline">
	</span><span class="oak-rightBrace">}</span><span class="oak-newline">
	</span><span class="oak-fnName">sub</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-comma">, </span><span class="oak-numberLiteral">0</span><span class="oak-rightParen">)</span>
<span class="oak-rightBrace">}</span>

<span class="oak-comment">// replace returns a string where all occurrences of the substring `old` has</span>
<span class="oak-comment">// been replaced by `new` in the string `s`. It does nothing for empty strings.</span>
<span class="oak-fnKeyword">fn </span><span class="oak-fnName">replace</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-comma">, </span><span class="oak-identifier">old</span><span class="oak-comma">, </span><span class="oak-identifier">new</span><span class="oak-rightParen">) </span><span class="oak-ifKeyword">if </span><span class="oak-identifier">old </span><span class="oak-leftBrace">{</span><span class="oak-newline">
	</span><span class="oak-stringLiteral">'' </span><span class="oak-branchArrow">-> </span><span class="oak-identifier">s</span><span class="oak-newline">
	</span><span class="oak-underscore">_ </span><span class="oak-branchArrow">-> </span><span class="oak-fnName">_replaceNonEmpty</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-comma">, </span><span class="oak-identifier">old</span><span class="oak-comma">, </span><span class="oak-identifier">new</span><span class="oak-rightParen">)</span>
<span class="oak-rightBrace">}</span>

<span class="oak-fnKeyword">fn </span><span class="oak-fnName">_splitNonEmpty</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-comma">, </span><span class="oak-identifier">sep</span><span class="oak-rightParen">) </span><span class="oak-leftBrace">{</span><span class="oak-newline">
	</span><span class="oak-identifier">coll </span><span class="oak-assign">:= </span><span class="oak-leftBracket">[</span><span class="oak-rightBracket">]</span><span class="oak-newline">
	</span><span class="oak-identifier">lsep </span><span class="oak-assign">:= </span><span class="oak-fnName">len</span><span class="oak-leftParen">(</span><span class="oak-identifier">sep</span><span class="oak-rightParen">)</span><span class="oak-newline">
	</span><span class="oak-fnKeyword">fn </span><span class="oak-fnName">sub</span><span class="oak-leftParen">(</span><span class="oak-identifier">acc</span><span class="oak-comma">, </span><span class="oak-identifier">i</span><span class="oak-comma">, </span><span class="oak-identifier">last</span><span class="oak-rightParen">) </span><span class="oak-ifKeyword">if </span><span class="oak-fnName">_matchesAt?</span><span class="oak-leftParen">(</span><span class="oak-identifier">acc</span><span class="oak-comma">, </span><span class="oak-identifier">sep</span><span class="oak-comma">, </span><span class="oak-identifier">i</span><span class="oak-rightParen">) </span><span class="oak-leftBrace">{</span><span class="oak-newline">
		</span><span class="oak-trueLiteral">true </span><span class="oak-branchArrow">-> </span><span class="oak-leftBrace">{</span><span class="oak-newline">
			</span><span class="oak-identifier">coll </span><span class="oak-pushArrow">&lt;&lt; </span><span class="oak-fnName">slice</span><span class="oak-leftParen">(</span><span class="oak-identifier">acc</span><span class="oak-comma">, </span><span class="oak-identifier">last</span><span class="oak-comma">, </span><span class="oak-identifier">i</span><span class="oak-rightParen">)</span><span class="oak-newline">
			</span><span class="oak-fnName">sub</span><span class="oak-leftParen">(</span><span class="oak-identifier">acc</span><span class="oak-comma">, </span><span class="oak-identifier">i </span><span class="oak-plus">+ </span><span class="oak-identifier">lsep</span><span class="oak-comma">, </span><span class="oak-identifier">i </span><span class="oak-plus">+ </span><span class="oak-identifier">lsep</span><span class="oak-rightParen">)</span><span class="oak-newline">
		</span><span class="oak-rightBrace">}</span><span class="oak-newline">
		</span><span class="oak-underscore">_ </span><span class="oak-branchArrow">-> </span><span class="oak-ifKeyword">if </span><span class="oak-identifier">i </span><span class="oak-less">&lt; </span><span class="oak-fnName">len</span><span class="oak-leftParen">(</span><span class="oak-identifier">acc</span><span class="oak-rightParen">) </span><span class="oak-leftBrace">{</span><span class="oak-newline">
			</span><span class="oak-trueLiteral">true </span><span class="oak-branchArrow">-> </span><span class="oak-fnName">sub</span><span class="oak-leftParen">(</span><span class="oak-identifier">acc</span><span class="oak-comma">, </span><span class="oak-identifier">i </span><span class="oak-plus">+ </span><span class="oak-numberLiteral">1</span><span class="oak-comma">, </span><span class="oak-identifier">last</span><span class="oak-rightParen">)</span><span class="oak-newline">
			</span><span class="oak-underscore">_ </span><span class="oak-branchArrow">-> </span><span class="oak-identifier">coll </span><span class="oak-pushArrow">&lt;&lt; </span><span class="oak-fnName">slice</span><span class="oak-leftParen">(</span><span class="oak-identifier">acc</span><span class="oak-comma">, </span><span class="oak-identifier">last</span><span class="oak-rightParen">)</span><span class="oak-newline">
		</span><span class="oak-rightBrace">}</span><span class="oak-newline">
	</span><span class="oak-rightBrace">}</span><span class="oak-newline">
	</span><span class="oak-fnName">sub</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-comma">, </span><span class="oak-numberLiteral">0</span><span class="oak-comma">, </span><span class="oak-numberLiteral">0</span><span class="oak-rightParen">)</span>
<span class="oak-rightBrace">}</span>

<span class="oak-comment">// split splits the string `s` by every occurrence of the substring `sep` in</span>
<span class="oak-comment">// it, and returns the result as a list of strings. If `sep` is not specified,</span>
<span class="oak-comment">// split returns a list of every character in the string in order.</span>
<span class="oak-fnKeyword">fn </span><span class="oak-fnName">split</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-comma">, </span><span class="oak-identifier">sep</span><span class="oak-rightParen">) </span><span class="oak-ifKeyword">if </span><span class="oak-identifier">sep </span><span class="oak-leftBrace">{</span><span class="oak-newline">
	</span><span class="oak-qmark">?</span><span class="oak-comma">, </span><span class="oak-stringLiteral">'' </span><span class="oak-branchArrow">-> </span><span class="oak-identifier">s </span><span class="oak-pipeArrow">|> </span><span class="oak-fnName">reduce</span><span class="oak-leftParen">(</span><span class="oak-leftBracket">[</span><span class="oak-rightBracket">]</span><span class="oak-comma">, </span><span class="oak-fnKeyword">fn</span><span class="oak-leftParen">(</span><span class="oak-identifier">acc</span><span class="oak-comma">, </span><span class="oak-identifier">c</span><span class="oak-rightParen">) </span><span class="oak-identifier">acc </span><span class="oak-pushArrow">&lt;&lt; </span><span class="oak-identifier">c</span><span class="oak-rightParen">)</span><span class="oak-newline">
	</span><span class="oak-underscore">_ </span><span class="oak-branchArrow">-> </span><span class="oak-fnName">_splitNonEmpty</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-comma">, </span><span class="oak-identifier">sep</span><span class="oak-rightParen">)</span>
<span class="oak-rightBrace">}</span>

<span class="oak-comment">// helper: repeat the string `pad` until it reaches exactly `n` characters.</span>
<span class="oak-fnKeyword">fn </span><span class="oak-fnName">_extend</span><span class="oak-leftParen">(</span><span class="oak-identifier">pad</span><span class="oak-comma">, </span><span class="oak-identifier">n</span><span class="oak-rightParen">) </span><span class="oak-leftBrace">{</span><span class="oak-newline">
	</span><span class="oak-identifier">times </span><span class="oak-assign">:= </span><span class="oak-fnName">int</span><span class="oak-leftParen">(</span><span class="oak-identifier">n </span><span class="oak-divide">/ </span><span class="oak-fnName">len</span><span class="oak-leftParen">(</span><span class="oak-identifier">pad</span><span class="oak-rightParen">)</span><span class="oak-rightParen">)</span><span class="oak-newline">
	</span><span class="oak-identifier">part </span><span class="oak-assign">:= </span><span class="oak-identifier">n </span><span class="oak-modulus">% </span><span class="oak-fnName">len</span><span class="oak-leftParen">(</span><span class="oak-identifier">pad</span><span class="oak-rightParen">)</span>
<span class="oak-newline">
	</span><span class="oak-fnKeyword">fn </span><span class="oak-fnName">sub</span><span class="oak-leftParen">(</span><span class="oak-identifier">base</span><span class="oak-comma">, </span><span class="oak-identifier">i</span><span class="oak-rightParen">) </span><span class="oak-ifKeyword">if </span><span class="oak-identifier">i </span><span class="oak-leftBrace">{</span><span class="oak-newline">
		</span><span class="oak-numberLiteral">0 </span><span class="oak-branchArrow">-> </span><span class="oak-identifier">base </span><span class="oak-pushArrow">&lt;&lt; </span><span class="oak-fnName">slice</span><span class="oak-leftParen">(</span><span class="oak-identifier">pad</span><span class="oak-comma">, </span><span class="oak-numberLiteral">0</span><span class="oak-comma">, </span><span class="oak-identifier">part</span><span class="oak-rightParen">)</span><span class="oak-newline">
		</span><span class="oak-underscore">_ </span><span class="oak-branchArrow">-> </span><span class="oak-fnName">sub</span><span class="oak-leftParen">(</span><span class="oak-identifier">base </span><span class="oak-pushArrow">&lt;&lt; </span><span class="oak-identifier">pad</span><span class="oak-comma">, </span><span class="oak-identifier">i </span><span class="oak-minus">- </span><span class="oak-numberLiteral">1</span><span class="oak-rightParen">)</span><span class="oak-newline">
	</span><span class="oak-rightBrace">}</span><span class="oak-newline">
	</span><span class="oak-fnName">sub</span><span class="oak-leftParen">(</span><span class="oak-stringLiteral">''</span><span class="oak-comma">, </span><span class="oak-identifier">times</span><span class="oak-rightParen">)</span>
<span class="oak-rightBrace">}</span>

<span class="oak-comment">// padStart prepends the string s with one or more repetitions of pad until the</span>
<span class="oak-comment">// total string is at least n characters long. If len(s) > n, it returns s.</span>
<span class="oak-fnKeyword">fn </span><span class="oak-fnName">padStart</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-comma">, </span><span class="oak-identifier">n</span><span class="oak-comma">, </span><span class="oak-identifier">pad</span><span class="oak-rightParen">) </span><span class="oak-ifKeyword">if </span><span class="oak-fnName">len</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-rightParen">) </span><span class="oak-geq">>= </span><span class="oak-identifier">n </span><span class="oak-leftBrace">{</span><span class="oak-newline">
	</span><span class="oak-trueLiteral">true </span><span class="oak-branchArrow">-> </span><span class="oak-identifier">s</span><span class="oak-newline">
	</span><span class="oak-underscore">_ </span><span class="oak-branchArrow">-> </span><span class="oak-fnName">_extend</span><span class="oak-leftParen">(</span><span class="oak-identifier">pad</span><span class="oak-comma">, </span><span class="oak-identifier">n </span><span class="oak-minus">- </span><span class="oak-fnName">len</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-rightParen">)</span><span class="oak-rightParen">) </span><span class="oak-pushArrow">&lt;&lt; </span><span class="oak-identifier">s</span>
<span class="oak-rightBrace">}</span>

<span class="oak-comment">// padEnd appends one or more repetitions of pad to the string s until the</span>
<span class="oak-comment">// total string is at least n characters long. If len(s) > n, it returns s.</span>
<span class="oak-fnKeyword">fn </span><span class="oak-fnName">padEnd</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-comma">, </span><span class="oak-identifier">n</span><span class="oak-comma">, </span><span class="oak-identifier">pad</span><span class="oak-rightParen">) </span><span class="oak-ifKeyword">if </span><span class="oak-fnName">len</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-rightParen">) </span><span class="oak-geq">>= </span><span class="oak-identifier">n </span><span class="oak-leftBrace">{</span><span class="oak-newline">
	</span><span class="oak-trueLiteral">true </span><span class="oak-branchArrow">-> </span><span class="oak-identifier">s</span><span class="oak-newline">
	</span><span class="oak-underscore">_ </span><span class="oak-branchArrow">-> </span><span class="oak-identifier">s </span><span class="oak-plus">+ </span><span class="oak-fnName">_extend</span><span class="oak-leftParen">(</span><span class="oak-identifier">pad</span><span class="oak-comma">, </span><span class="oak-identifier">n </span><span class="oak-minus">- </span><span class="oak-fnName">len</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-rightParen">)</span><span class="oak-rightParen">)</span>
<span class="oak-rightBrace">}</span>

<span class="oak-fnKeyword">fn </span><span class="oak-fnName">_trimStartSpace</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-rightParen">) </span><span class="oak-leftBrace">{</span><span class="oak-newline">
	</span><span class="oak-fnKeyword">fn </span><span class="oak-fnName">subStart</span><span class="oak-leftParen">(</span><span class="oak-identifier">i</span><span class="oak-rightParen">) </span><span class="oak-ifKeyword">if </span><span class="oak-fnName">space?</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-dot">.</span><span class="oak-leftParen">(</span><span class="oak-identifier">i</span><span class="oak-rightParen">)</span><span class="oak-rightParen">) </span><span class="oak-leftBrace">{</span><span class="oak-newline">
		</span><span class="oak-trueLiteral">true </span><span class="oak-branchArrow">-> </span><span class="oak-fnName">subStart</span><span class="oak-leftParen">(</span><span class="oak-identifier">i </span><span class="oak-plus">+ </span><span class="oak-numberLiteral">1</span><span class="oak-rightParen">)</span><span class="oak-newline">
		</span><span class="oak-underscore">_ </span><span class="oak-branchArrow">-> </span><span class="oak-identifier">i</span><span class="oak-newline">
	</span><span class="oak-rightBrace">}</span><span class="oak-newline">
	</span><span class="oak-identifier">firstNonSpace </span><span class="oak-assign">:= </span><span class="oak-fnName">subStart</span><span class="oak-leftParen">(</span><span class="oak-numberLiteral">0</span><span class="oak-rightParen">)</span><span class="oak-newline">
	</span><span class="oak-fnName">slice</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-comma">, </span><span class="oak-identifier">firstNonSpace</span><span class="oak-rightParen">)</span>
<span class="oak-rightBrace">}</span>

<span class="oak-fnKeyword">fn </span><span class="oak-fnName">_trimStartNonEmpty</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-comma">, </span><span class="oak-identifier">prefix</span><span class="oak-rightParen">) </span><span class="oak-leftBrace">{</span><span class="oak-newline">
	</span><span class="oak-identifier">max </span><span class="oak-assign">:= </span><span class="oak-fnName">len</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-rightParen">)</span><span class="oak-newline">
	</span><span class="oak-identifier">lpref </span><span class="oak-assign">:= </span><span class="oak-fnName">len</span><span class="oak-leftParen">(</span><span class="oak-identifier">prefix</span><span class="oak-rightParen">)</span><span class="oak-newline">
	</span><span class="oak-fnKeyword">fn </span><span class="oak-fnName">sub</span><span class="oak-leftParen">(</span><span class="oak-identifier">i</span><span class="oak-rightParen">) </span><span class="oak-ifKeyword">if </span><span class="oak-identifier">i </span><span class="oak-less">&lt; </span><span class="oak-identifier">max </span><span class="oak-leftBrace">{</span><span class="oak-newline">
		</span><span class="oak-trueLiteral">true </span><span class="oak-branchArrow">-> </span><span class="oak-ifKeyword">if </span><span class="oak-fnName">_matchesAt?</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-comma">, </span><span class="oak-identifier">prefix</span><span class="oak-comma">, </span><span class="oak-identifier">i</span><span class="oak-rightParen">) </span><span class="oak-leftBrace">{</span><span class="oak-newline">
			</span><span class="oak-trueLiteral">true </span><span class="oak-branchArrow">-> </span><span class="oak-fnName">sub</span><span class="oak-leftParen">(</span><span class="oak-identifier">i </span><span class="oak-plus">+ </span><span class="oak-identifier">lpref</span><span class="oak-rightParen">)</span><span class="oak-newline">
			</span><span class="oak-underscore">_ </span><span class="oak-branchArrow">-> </span><span class="oak-identifier">i</span><span class="oak-newline">
		</span><span class="oak-rightBrace">}</span><span class="oak-newline">
		</span><span class="oak-underscore">_ </span><span class="oak-branchArrow">-> </span><span class="oak-identifier">i</span><span class="oak-newline">
	</span><span class="oak-rightBrace">}</span><span class="oak-newline">
	</span><span class="oak-identifier">idx </span><span class="oak-assign">:= </span><span class="oak-fnName">sub</span><span class="oak-leftParen">(</span><span class="oak-numberLiteral">0</span><span class="oak-rightParen">)</span><span class="oak-newline">
	</span><span class="oak-fnName">slice</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-comma">, </span><span class="oak-identifier">idx</span><span class="oak-rightParen">)</span>
<span class="oak-rightBrace">}</span>

<span class="oak-comment">// trimStart removes any (potentially repeated) occurrences of the string</span>
<span class="oak-comment">// `prefix` from the beginning of string `s`</span>
<span class="oak-fnKeyword">fn </span><span class="oak-fnName">trimStart</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-comma">, </span><span class="oak-identifier">prefix</span><span class="oak-rightParen">) </span><span class="oak-ifKeyword">if </span><span class="oak-identifier">prefix </span><span class="oak-leftBrace">{</span><span class="oak-newline">
	</span><span class="oak-stringLiteral">'' </span><span class="oak-branchArrow">-> </span><span class="oak-identifier">s</span><span class="oak-newline">
	</span><span class="oak-qmark">? </span><span class="oak-branchArrow">-> </span><span class="oak-fnName">_trimStartSpace</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-rightParen">)</span><span class="oak-newline">
	</span><span class="oak-underscore">_ </span><span class="oak-branchArrow">-> </span><span class="oak-fnName">_trimStartNonEmpty</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-comma">, </span><span class="oak-identifier">prefix</span><span class="oak-rightParen">)</span>
<span class="oak-rightBrace">}</span>

<span class="oak-fnKeyword">fn </span><span class="oak-fnName">_trimEndSpace</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-rightParen">) </span><span class="oak-leftBrace">{</span><span class="oak-newline">
	</span><span class="oak-fnKeyword">fn </span><span class="oak-fnName">subEnd</span><span class="oak-leftParen">(</span><span class="oak-identifier">i</span><span class="oak-rightParen">) </span><span class="oak-ifKeyword">if </span><span class="oak-fnName">space?</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-dot">.</span><span class="oak-leftParen">(</span><span class="oak-identifier">i</span><span class="oak-rightParen">)</span><span class="oak-rightParen">) </span><span class="oak-leftBrace">{</span><span class="oak-newline">
		</span><span class="oak-trueLiteral">true </span><span class="oak-branchArrow">-> </span><span class="oak-fnName">subEnd</span><span class="oak-leftParen">(</span><span class="oak-identifier">i </span><span class="oak-minus">- </span><span class="oak-numberLiteral">1</span><span class="oak-rightParen">)</span><span class="oak-newline">
		</span><span class="oak-underscore">_ </span><span class="oak-branchArrow">-> </span><span class="oak-identifier">i</span><span class="oak-newline">
	</span><span class="oak-rightBrace">}</span><span class="oak-newline">
	</span><span class="oak-identifier">lastNonSpace </span><span class="oak-assign">:= </span><span class="oak-fnName">subEnd</span><span class="oak-leftParen">(</span><span class="oak-fnName">len</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-rightParen">) </span><span class="oak-minus">- </span><span class="oak-numberLiteral">1</span><span class="oak-rightParen">)</span><span class="oak-newline">
	</span><span class="oak-fnName">slice</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-comma">, </span><span class="oak-numberLiteral">0</span><span class="oak-comma">, </span><span class="oak-identifier">lastNonSpace </span><span class="oak-plus">+ </span><span class="oak-numberLiteral">1</span><span class="oak-rightParen">)</span>
<span class="oak-rightBrace">}</span>

<span class="oak-fnKeyword">fn </span><span class="oak-fnName">_trimEndNonEmpty</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-comma">, </span><span class="oak-identifier">suffix</span><span class="oak-rightParen">) </span><span class="oak-leftBrace">{</span><span class="oak-newline">
	</span><span class="oak-identifier">lsuf </span><span class="oak-assign">:= </span><span class="oak-fnName">len</span><span class="oak-leftParen">(</span><span class="oak-identifier">suffix</span><span class="oak-rightParen">)</span><span class="oak-newline">
	</span><span class="oak-fnKeyword">fn </span><span class="oak-fnName">sub</span><span class="oak-leftParen">(</span><span class="oak-identifier">i</span><span class="oak-rightParen">) </span><span class="oak-ifKeyword">if </span><span class="oak-identifier">i </span><span class="oak-greater">> </span><span class="oak-minus">-</span><span class="oak-numberLiteral">1 </span><span class="oak-leftBrace">{</span><span class="oak-newline">
		</span><span class="oak-trueLiteral">true </span><span class="oak-branchArrow">-> </span><span class="oak-ifKeyword">if </span><span class="oak-fnName">_matchesAt?</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-comma">, </span><span class="oak-identifier">suffix</span><span class="oak-comma">, </span><span class="oak-identifier">i </span><span class="oak-minus">- </span><span class="oak-identifier">lsuf</span><span class="oak-rightParen">) </span><span class="oak-leftBrace">{</span><span class="oak-newline">
			</span><span class="oak-trueLiteral">true </span><span class="oak-branchArrow">-> </span><span class="oak-fnName">sub</span><span class="oak-leftParen">(</span><span class="oak-identifier">i </span><span class="oak-minus">- </span><span class="oak-identifier">lsuf</span><span class="oak-rightParen">)</span><span class="oak-newline">
			</span><span class="oak-underscore">_ </span><span class="oak-branchArrow">-> </span><span class="oak-identifier">i</span><span class="oak-newline">
		</span><span class="oak-rightBrace">}</span><span class="oak-newline">
		</span><span class="oak-underscore">_ </span><span class="oak-branchArrow">-> </span><span class="oak-identifier">i</span><span class="oak-newline">
	</span><span class="oak-rightBrace">}</span><span class="oak-newline">
	</span><span class="oak-identifier">idx </span><span class="oak-assign">:= </span><span class="oak-fnName">sub</span><span class="oak-leftParen">(</span><span class="oak-fnName">len</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-rightParen">)</span><span class="oak-rightParen">)</span><span class="oak-newline">
	</span><span class="oak-fnName">slice</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-comma">, </span><span class="oak-numberLiteral">0</span><span class="oak-comma">, </span><span class="oak-identifier">idx</span><span class="oak-rightParen">)</span>
<span class="oak-rightBrace">}</span>

<span class="oak-comment">// trimEnd removes any (potentially repeated) occurrences of the string</span>
<span class="oak-comment">// `suffix` from the end of string `s`</span>
<span class="oak-fnKeyword">fn </span><span class="oak-fnName">trimEnd</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-comma">, </span><span class="oak-identifier">suffix</span><span class="oak-rightParen">) </span><span class="oak-ifKeyword">if </span><span class="oak-identifier">suffix </span><span class="oak-leftBrace">{</span><span class="oak-newline">
	</span><span class="oak-stringLiteral">'' </span><span class="oak-branchArrow">-> </span><span class="oak-identifier">s</span><span class="oak-newline">
	</span><span class="oak-qmark">? </span><span class="oak-branchArrow">-> </span><span class="oak-fnName">_trimEndSpace</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-rightParen">)</span><span class="oak-newline">
	</span><span class="oak-underscore">_ </span><span class="oak-branchArrow">-> </span><span class="oak-fnName">_trimEndNonEmpty</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-comma">, </span><span class="oak-identifier">suffix</span><span class="oak-rightParen">)</span>
<span class="oak-rightBrace">}</span>

<span class="oak-comment">// trim removes any (potentially repeated) ocucrrences of the string `part`</span>
<span class="oak-comment">// from either end of the string `s`. If `part` is not specified, trim removes</span>
<span class="oak-comment">// all whitespace from either end of the string `s`.</span>
<span class="oak-fnKeyword">fn </span><span class="oak-fnName">trim</span><span class="oak-leftParen">(</span><span class="oak-identifier">s</span><span class="oak-comma">, </span><span class="oak-identifier">part</span><span class="oak-rightParen">) </span><span class="oak-identifier">s </span><span class="oak-pipeArrow">|> </span><span class="oak-fnName">trimStart</span><span class="oak-leftParen">(</span><span class="oak-identifier">part</span><span class="oak-rightParen">) </span><span class="oak-pipeArrow">|> </span><span class="oak-fnName">trimEnd</span><span class="oak-leftParen">(</span><span class="oak-identifier">part</span><span class="oak-rightParen">)</span>

</code></pre>
        </article>
    </main>
    <footer>
        <div class="split overlay">
            <div class="left">
            </div>
            <div class="right">
                - <a href="https://thesephist.com/">Linus</a>
            </div>
        </div>
    </footer>
</body>
